<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="goon Fred" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"always","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="概述本篇博文主要记录TS稍进阶的一些基础内容，大致以下几个知识点：  泛型 class（ES6和TS） 枚举 类型兼容性  泛型泛型指在函数定义时，可以在函数括号前先定义一个泛型变量容器，并不具体指定类型；然后函数括号中就可以使用这个泛型容器来代替类型； 这个泛型变量可以在函数调用时传入，确定具体的类型； 1234567&#x2F;&#x2F; 定义泛型变量const getValue = &amp;lt;T&amp;gt;(pr1">
<meta name="keywords" content="TypeScript">
<meta property="og:type" content="article">
<meta property="og:title" content="typescript轻度进阶">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;02&#x2F;23&#x2F;typescript-02&#x2F;index.html">
<meta property="og:site_name" content="goon Fred">
<meta property="og:description" content="概述本篇博文主要记录TS稍进阶的一些基础内容，大致以下几个知识点：  泛型 class（ES6和TS） 枚举 类型兼容性  泛型泛型指在函数定义时，可以在函数括号前先定义一个泛型变量容器，并不具体指定类型；然后函数括号中就可以使用这个泛型容器来代替类型； 这个泛型变量可以在函数调用时传入，确定具体的类型； 1234567&#x2F;&#x2F; 定义泛型变量const getValue = &amp;lt;T&amp;gt;(pr1">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-02-23T09:49:22.922Z">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/02/23/typescript-02/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>typescript轻度进阶 | goon Fred</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">goon Fred</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>日志</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/23/typescript-02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://i.loli.net/2019/11/24/1eJtrwT9h7oLmW2.png">
      <meta itemprop="name" content="酵父">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="goon Fred">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          typescript轻度进阶
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-23 17:39:58 / 修改时间：17:49:22" itemprop="dateCreated datePublished" datetime="2020-02-23T17:39:58+08:00">2020-02-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本篇博文主要记录TS稍进阶的一些基础内容，大致以下几个知识点：</p>
<ul>
<li>泛型</li>
<li>class（ES6和TS）</li>
<li>枚举</li>
<li>类型兼容性</li>
</ul>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型指在函数定义时，可以在函数括号前先定义一个泛型变量容器，并不具体指定类型；然后函数括号中就可以使用这个泛型容器来代替类型；</p>
<p>这个泛型变量可以在函数调用时传入，确定具体的类型；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 定义泛型变量</span><br><span class="line">const getValue = &lt;T&gt;(pr1: T, pr2: number): T[] =&gt; &#123;</span><br><span class="line">  return new Array(pr2).fill(pr1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用传入泛型变量具体类型</span><br><span class="line">console.log(getValue&lt;string&gt;(&apos;awesome&apos;, 3).map(e =&gt; e.length)); // =》  [7, 7, 7]</span><br></pre></td></tr></table></figure>

<h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function loggingIdentity&lt;T&gt;(arg: T): T &#123;</span><br><span class="line">    console.log(arg.length);</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// index.ts(2,19): error TS2339: Property &apos;length&apos; does not exist on type &apos;T&apos;.</span><br></pre></td></tr></table></figure>

<p>上例中，泛型 <code>T</code> 不一定包含属性 <code>length</code>，所以编译的时候报错了。</p>
<p>所以我们需要对这个泛型变量做一个约束，我们可以使用 <code>extends</code> 约束泛型  必须符合某个接口的形状;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Lengthwise &#123;</span><br><span class="line">    length: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123;</span><br><span class="line">    console.log(arg.length);</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>约束加索引类型</strong></p>
<p>如果一个函数传入的两个参数，必须有所属依赖关系，那么我们同样可以使用<code>extends</code>来实现；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const getValue = &lt;T, K extends keyof T&gt;(obj1: T, prop: K) =&gt; &#123;</span><br><span class="line">    return obj1[prop];</span><br><span class="line">&#125;</span><br><span class="line">// 现在我们传入的prop，必须是obj1的其中之一属性；</span><br><span class="line">const obj = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2</span><br><span class="line">&#125;</span><br><span class="line">getValue(obj, a);   // 第二个参数必须是a 或者 b；</span><br></pre></td></tr></table></figure>

<h3 id="keyof"><a href="#keyof" class="headerlink" title="keyof"></a>keyof</h3><p>上面使用的<code>keyof</code>， 是typescript中的<code>keyof</code>关键字，作用是将一个类型映射为它所有成员名称的联合类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">    location: string;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">type K1 = keyof Person;                   // &quot;name&quot; | &quot;age&quot; | &quot;location&quot;</span><br><span class="line">type K2 = keyof Person[];                 // &quot;length&quot; | &quot;push&quot; | &quot;pop&quot; | &quot;concat&quot; | ...</span><br><span class="line">type K3 = keyof &#123; [x: string]: Person &#125;;  // string</span><br></pre></td></tr></table></figure>

<p><code>keyof</code>实际给我们一个操作联合类型的途径。结合typescript的其他feature，如类型映射与索引类型，我们得以在对象类型与联合类型之间游刃有余地转换，为工程中更多变量找到最适合的类型归属。</p>
<blockquote>
<p>索引类型和映射类型在后面的博文详细记录。</p>
</blockquote>
<h3 id="实例：多参数泛型约束"><a href="#实例：多参数泛型约束" class="headerlink" title="实例：多参数泛型约束"></a>实例：多参数泛型约束</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const limit = &lt;T, K extends keyof T&gt;(</span><br><span class="line">  obj: T,</span><br><span class="line">  key: K[],</span><br><span class="line">  length: number</span><br><span class="line">): T[K][] =&gt; &#123;</span><br><span class="line">  const res = key.map(e =&gt; &#123;</span><br><span class="line">    return obj[e];</span><br><span class="line">  &#125;);</span><br><span class="line">  return res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type IMap = &#123; name: string; age: number &#125;;</span><br><span class="line">type IKey = keyof IMap;</span><br><span class="line"></span><br><span class="line">const obj: IMap = &#123; name: &quot;fred&quot;, age: 26 &#125;;</span><br><span class="line">const keys: IKey[] = [&quot;age&quot;, &quot;name&quot;];</span><br><span class="line"></span><br><span class="line">console.log(limit&lt;IMap, IKey&gt;(obj, keys));    // 这就约束了，keys参数必须是ojb键值的数组</span><br></pre></td></tr></table></figure>





<h2 id="ES6中的类"><a href="#ES6中的类" class="headerlink" title="ES6中的类"></a>ES6中的类</h2><p>传统方法中，JavaScript 通过构造函数实现类的概念，通过原型链实现继承。而在 ES6 中，终于迎来了 <code>class</code>。</p>
<h3 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h3><p>使用 <code>class</code> 定义类，使用 <code>constructor</code> 定义构造函数。</p>
<p>通过 <code>new</code> 生成新实例的时候，会自动调用构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    constructor(name) &#123;                     // constructor就相当于ES5中的构造函数</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    sayHi() &#123;                               // class中的方法，就相当于与ES5中构造函数原型对象上的方法</span><br><span class="line">        return `My name is $&#123;this.name&#125;`;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = new Animal(&apos;Jack&apos;);</span><br><span class="line">console.log(a.sayHi()); // My name is Jack</span><br></pre></td></tr></table></figure>

<h3 id="静态static方法"><a href="#静态static方法" class="headerlink" title="静态static方法"></a>静态static方法</h3><p>可以给类设置静态方法，这个方法只有通过类自身来调用，不继承给实例对象；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Cars &#123;</span><br><span class="line">  color: any;</span><br><span class="line">  constructor(color) &#123;</span><br><span class="line">    this.color = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // class静态方法</span><br><span class="line">  static getStaticName() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用静态方法</span><br><span class="line">console.log(Cars.getStaticName());  // Cars</span><br><span class="line">const tesla = new Cars(&apos;blue&apos;);</span><br><span class="line">console.log(tesla.getStaticName());  // undefined</span><br></pre></td></tr></table></figure>



<h3 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h3><p>使用 getter 和 setter 可以改变属性的赋值和读取行为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    get name() &#123;</span><br><span class="line">        return &apos;Jack&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    set name(value) &#123;</span><br><span class="line">        console.log(&apos;setter: &apos; + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let a = new Animal(&apos;Kitty&apos;); // setter: Kitty</span><br><span class="line">a.name = &apos;Tom&apos;; // setter: Tom</span><br><span class="line">console.log(a.name); // Jack</span><br></pre></td></tr></table></figure>

<p>这个例子设置的存取器作用对象是这个Class类，创造出的<strong>实例</strong>的<code>name</code>属性；</p>
<p>也就是<code>a</code> 上的 name属性 存取操作；</p>
<p>那么如果<code>set</code>&amp;<code>get</code>指定的是一个该实例身上没有的属性呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Car &#123;</span><br><span class="line">  constructor(color) &#123;</span><br><span class="line">    this.color = color;</span><br><span class="line">  &#125;</span><br><span class="line">  set power(newVal) &#123;</span><br><span class="line">    console.log(&apos;新值为&apos; + newVal);</span><br><span class="line">  &#125;</span><br><span class="line">  get power() &#123;</span><br><span class="line">    console.log(&apos;取值&apos;);</span><br><span class="line">    return &apos;123replace&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 那么此时会自动创造出 实例的 power属性</span><br><span class="line">const infinit = new Car(&apos;blue&apos;);</span><br><span class="line">infinit.power = &quot;V8&quot;;                      // 新值为V8</span><br><span class="line">console.log(infinit.power);                // 取值 123replace</span><br></pre></td></tr></table></figure>

<p>此时会自动给实例添加<code>power</code>属性， 并且取值为<code>get</code>的返回值 =&gt; <code>123replace</code>；</p>
<h3 id="类的私有方法"><a href="#类的私有方法" class="headerlink" title="类的私有方法"></a>类的私有方法</h3><p><strong>第一种方法：直接定义外部方法</strong></p>
<p>可以在当前模块内，此类之外，定义一个功能方法；然后在类中引用这个外部方法；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">type ISpeed = (s?: number) =&gt; string;</span><br><span class="line"></span><br><span class="line">function speed(s = 160): ISpeed &#123;</span><br><span class="line">  this.speeds = `$&#123;s&#125;km/h`;  // 这里的this指向global</span><br><span class="line">  return this.speeds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cars &#123;</span><br><span class="line">  color: any;</span><br><span class="line">  constructor(color) &#123;</span><br><span class="line">    this.color = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleForFirst() &#123;</span><br><span class="line">    const tmp = speed.call(this, 260); // 这里的this， 指向当前实例对象</span><br><span class="line">    return tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const infinit = new Cars(&quot;blue&quot;);</span><br><span class="line">console.log(infinit.handleForFirst()); // 260km/h</span><br><span class="line">console.log(infinit); // Cars &#123;color: &quot;blue&quot;, speeds: &quot;260km/h&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>这样其他模块只获取当前<code>Cars</code>类时， 是无法获取其中调用的<code>speed</code>方法的；</p>
<p>那么这个方法就可以称为类中的私有方法；</p>
<p><strong>第二种方法：使用Symbol定义外部方法名</strong></p>
<p>因为Symbol唯一性，在类class中使用symbol作为方法名，那么如果本模块不导出该<code>Symbol</code>，那么外部就无法获取类中的此方法；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 第二种私有方法</span><br><span class="line">const scope = Symbol(&quot;scopeHandle&quot;);</span><br><span class="line"></span><br><span class="line">export default class Cars &#123;</span><br><span class="line">  color: any;</span><br><span class="line">  constructor(color) &#123;</span><br><span class="line">    this.color = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 第二种私有方法使用</span><br><span class="line">  [scope]() &#123;</span><br><span class="line">    console.log(&quot;调用私有方法&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  checkScopeHandle() &#123;                     // 类中调用私有方法</span><br><span class="line">    this[scope]();						// 此类之外，无法直接调用私有方法</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为该<code>Symbol</code>方法名唯一性，所以其他模块文件引入此类时，无法调用其中的<code>Symbol</code>方法；</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><code>es6</code>中的class实际相当于<code>es5</code>中原型对象继承的<code>语法糖</code>;</p>
<p>我们可以通过<code>extends</code>关键字实现继承；</p>
<p><strong>先定义一个父类；</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    return `my name is $&#123;this.name&#125;~`;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再定义一个子类，继承父类；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Coder extends Person &#123;</span><br><span class="line">  type: string;</span><br><span class="line">  constructor(name, type) &#123;</span><br><span class="line">    super(name);             // 这里的super()， 关键字实现了继承父类方法和属性；</span><br><span class="line">    this.type = type;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用<code>super()</code>，来继承父类上的属性和方法；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const frontEnd = new Coder(&quot;fred-evo&quot;, &quot;front-end-dev&quot;);</span><br><span class="line">console.log(frontEnd.getName());          // my name is fred-evo~</span><br></pre></td></tr></table></figure>

<p>因为<code>super()</code>中，我们传入了第一个参数<code>name</code>，相当于传递给了父类的构造函数；</p>
<p>所以子类的实例对象上，就继承包含了<code>name</code>,<code>type</code>属性以及<code>getName()</code>方法；</p>
<h3 id="实例对象"><a href="#实例对象" class="headerlink" title="实例对象"></a>实例对象</h3><p>此时因为子类<code>Coder</code>是继承了<code>Person</code>父类，所以子类创建出来的实例对象，既属于<code>Coder</code>类，又属于<code>Person</code>；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(frontEnd instanceof Coder);  // true</span><br><span class="line">console.log(frontEnd instanceof Person); // true</span><br></pre></td></tr></table></figure>

<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>类上的<code>static</code>静态方法，也可以通过<code>extends</code>继承给子类；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    console.log(this);     // ===&gt; 这里的this，指向当前实例对象</span><br><span class="line">    return `my name is $&#123;this.name&#125;~`;</span><br><span class="line">  &#125;</span><br><span class="line">  static getClassOwnName() &#123;</span><br><span class="line">    console.log(this);     // ===&gt; 这里的this，指向当前class类， Person</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Coder extends Person &#123;</span><br><span class="line">  type: string;</span><br><span class="line">  constructor(name, type) &#123;</span><br><span class="line">    super(name);</span><br><span class="line">    this.type = type;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时相当于，<code>Coder</code>和<code>Person</code>类上都有了静态方法<code>getClassOwnName()</code>；</p>
<p>但是this的指向确是不一样的；</p>
<ul>
<li>类中原型对象上的方法，this指向是当前实例对象；</li>
<li>而<code>static</code>静态方法中，this指向则是当前的<code>class</code>类；</li>
</ul>
<p>所以此时，<code>coder</code>类继承过来的静态方法，调用时，this指向的是自己；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 静态方法继承</span><br><span class="line">console.log(Coder.getClassOwnName());   // Coder</span><br><span class="line">console.log(Person.getClassOwnName());  // Person</span><br></pre></td></tr></table></figure>

<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>可作为<code>函数方法</code>以及<code>对象</code>两种类型来使用；、</p>
<ul>
<li><h3 id="函数方法"><a href="#函数方法" class="headerlink" title="函数方法"></a>函数方法</h3><p>作为函数方法使用时，有两个条件：</p>
<ol>
<li><p><strong>只能在构造函数</strong><code>constructor</code>中调用；（不可在类中的其他普通方法里调用）</p>
</li>
<li><p>并且，继承类的构造函数中，<strong>必须调用<code>super</code>方法</strong>，来继承父类的属性和方法；（调用后，才能使用this）</p>
</li>
</ol>
<p>这里需要注意，上面这两点是相互依赖的。缺一就会报错。</p>
<p>这里的<code>super</code>意义是代表继承<code>父类的构造函数</code>，可以传入参数；实际就相当于子类调用了父类的构造函数，并且父类构造函数中的<code>this</code>， 也都指向了当前子类自己的实例对象。</p>
</li>
<li><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>作为对象使用时， 又分为两种情况；</p>
<ol>
<li><p>在类中的静态方法中使用;</p>
<p>这里<code>super</code>代表的是：<strong>父类class；</strong></p>
<p>我们可以通过<code>super.XXX</code>, 来调用其父类的静态方法；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Parent &#123;</span><br><span class="line">  static testInfo() &#123;</span><br><span class="line">    alert(&quot;testInfo&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line">  getParent() &#123;</span><br><span class="line">    super.getParentInfo(&quot;im in handle&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  static childHandle() &#123;</span><br><span class="line">    console.log(super.testInfo);     ======》// 这里的super代表父类本身</span><br><span class="line">                                             // 输出为父类的静态方法</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ul>
<ol start="2">
<li><p>在类中除了静态方法外的 普通方法中使用；（包括constructor）</p>
<p>这里的<code>super</code>代表的是： <strong>父类的原型对象</strong></p>
<p>可以通过<code>super</code>调用，父类中基于原型对象的方法（只有方法，不可调用属性）；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Parent &#123;</span><br><span class="line">  getParentInfo(info) &#123;</span><br><span class="line">    console.log(&quot;parent Info Send~&quot; + info);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    super.getParentInfo(&quot;haha, im in constructor&quot;);  // 这里的super代表父类原型对象</span><br><span class="line">  &#125;</span><br><span class="line">  getParent() &#123;</span><br><span class="line">    super.getParentInfo(&quot;im in handle&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>super</code>调用中，父类方法中的this，都指向了当前子类调用环境的this。</p>
</li>
</ol>
<h3 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h3><p>我们可以通过<code>Object.getPrototypeOf()</code>，来判断某个类的原型对象；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.getPrototypeOf(Coder) === Person);   // true</span><br></pre></td></tr></table></figure>

<p>在<code>ES6</code>中的class，可以通过<code>__proto__</code>得出：</p>
<ol>
<li>子类的<code>__proto__</code>属性，表示其父类；</li>
<li>子类的<code>prototype</code>属性中的<code>__proto__</code>属性，指向父类的<code>prototype</code>属性；</li>
</ol>
<p>原型链知识，单独按图记录。</p>
<h3 id="ES6和ES5继承的区别"><a href="#ES6和ES5继承的区别" class="headerlink" title="ES6和ES5继承的区别"></a>ES6和ES5继承的区别</h3><p>讲了一堆class内容，这里总结一下ES5和ES6中class继承的区别：</p>
<ul>
<li><p>ES5的继承，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Father() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Children(...args)&#123;</span><br><span class="line">    Father.apply(this, args)</span><br><span class="line">&#125;</span><br><span class="line">Children.prototype = new Father()</span><br></pre></td></tr></table></figure>

<p>实质是先创造子类的实例对象this，然后再将父类的私有属性添加到this上面，</p>
<p>最后来改变原型链的指向。</p>
</li>
<li><p>ES6的继承机制完全不同，实质是先创造父类的实例对象this；<br>所以必须先调用super方法，（即便子类没有书写constructor也会默认添加）<br>然后再用子类的构造函数修改this。</p>
</li>
</ul>
<h2 id="TS中的类"><a href="#TS中的类" class="headerlink" title="TS中的类"></a>TS中的类</h2><p>上面是ES6中class的使用和定义，现在说一下TS中的类有哪些新特性。</p>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>TS类包含三种修饰符： <code>public</code>，<code>private</code>，<code>protected</code>；（JAVA CODER应该很熟悉）</p>
<p>下面说一下各自的意义和作用：</p>
<ul>
<li><p><code>public</code>代表公共属性及方法，如果不写修饰符，也是默认为<code>public</code>；</p>
<ul>
<li>本类中：   可以使用</li>
<li>子类中：   可以使用</li>
<li>实例中（类外部）：可以使用</li>
</ul>
<p>公共属性表示不光在<code>class</code>中可以使用this进行获取及设置，在创建的实例中，也可以进行操作；</p>
</li>
<li><p><code>private</code>代表类的私有方法，只能在类中操作；</p>
<ul>
<li>本类中：   可以使用</li>
<li>子类中：   不可使用</li>
<li>实例中（类外部）：不可使用</li>
</ul>
<p>类创建的实例及其子类，无法对私有属性及方法，进行读取或操作；</p>
</li>
<li><p><code>protected</code> 代表类的受保护方法，只能在其类中及子类中操作；</p>
<ul>
<li>本类中：   可以使用</li>
<li>子类中：   可以使用</li>
<li>实例中（类外部）：不可使用</li>
</ul>
<p>类受保护的方法，只能在类中使用，不可在类外部（创建的实例）中使用操作；</p>
</li>
</ul>
<p>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Parent &#123;</span><br><span class="line">  public name: string;                           // 公共属性</span><br><span class="line">  protected money: number;                      // 受保护属性</span><br><span class="line">  private length: string = &quot;18cm&quot;;             // 私有属性</span><br><span class="line">  constructor(name, money = 1500) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.money = money;</span><br><span class="line">  &#125;</span><br><span class="line">  protected getName() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line">  public readonly age: number;</span><br><span class="line">  constructor(name, age) &#123;</span><br><span class="line">    super(name);</span><br><span class="line">    this.age = age;</span><br><span class="line">    console.log(super.getName);</span><br><span class="line">  &#125;</span><br><span class="line">  public testRunMod() &#123;</span><br><span class="line">    console.log(this.name);                      // okay</span><br><span class="line">    console.log(this.money);                    // okay， 受保护属性可以在子类中使用</span><br><span class="line">    console.log(this.age);</span><br><span class="line">    console.log(this.length);                      // error!报错，私有属性只能在Parent本类中使用</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="readonly修饰符"><a href="#readonly修饰符" class="headerlink" title="readonly修饰符"></a>readonly修饰符</h3><p>可以在类中设置只读属性，这样外部就不可进行此属性的修改；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Child extends Parent &#123;</span><br><span class="line">  public readonly age: number;             // 设置只读属性</span><br><span class="line">  constructor() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const c = new Child();</span><br><span class="line">c.age = 18;              // error, 不可修改</span><br></pre></td></tr></table></figure>

<h3 id="参数属性简写"><a href="#参数属性简写" class="headerlink" title="参数属性简写"></a>参数属性简写</h3><p>我们可以通过利用 <code>Typescript</code> 提供的简写形式，直接用构造函数的参数定义属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Car &#123;</span><br><span class="line">  constructor(public name: string) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">const tesla = new Car(&quot;tesla&quot;);</span><br><span class="line">console.log(tesla);                      // &#123; name: &apos;tesla&apos; &#125;</span><br></pre></td></tr></table></figure>

<p>这里看上去，虽然没有在<code>constructor</code>构造函数中使用<code>this</code>为实例指定属性，</p>
<p>但实际上通过直接给<code>name</code>增加参数属性<code>public</code>，就已经给实例增加了初始属性<code>name</code>;</p>
<p>总结一下这种简写语法实际做了什么：</p>
<ol>
<li>声明了一个构造函数初始参数名及其类型；</li>
<li>给这个属性声明为公共属性；</li>
<li>当我们创建该类的实例时，把该属性初始化为相应的参数属性值；</li>
</ol>
<p>也就是相当于下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Car &#123;</span><br><span class="line">  public name:string;          // 1、2</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">  	this.name = name;          // 3</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const tesla = new Car(&quot;tesla&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p>class中可以使用<code>?</code>来设置可选属性；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Info&#123;</span><br><span class="line">	public name?:string;</span><br><span class="line">	constructor(name?: string) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="存取器-1"><a href="#存取器-1" class="headerlink" title="存取器"></a>存取器</h3><p>使用和<code>ES6</code>中保持一致；</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p><code>abstract</code> 用于定义抽象类和其中的抽象方法。抽象类一般用来被其他类继承，而不直接用来创建实例。</p>
<p>并且抽象类中定义的方法/存取器，子类必须实现。  看下面例子即可明白：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">abstract class Tmp &#123;</span><br><span class="line">  constructor(public name: string) &#123;&#125;</span><br><span class="line">  abstract set age(val: string);              // 定义存取器</span><br><span class="line">  abstract getName(): void;                   // 抽象类中定义的方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class RealClass extends Tmp &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    super(name);</span><br><span class="line">  &#125;</span><br><span class="line">  public set age() &#123;                            // 继承的存取器，必须在子类中实现（否则报错）</span><br><span class="line">  	console.log(&apos;age === 26&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  public getName() &#123;                              // 继承的抽象方法，必须在子类中实现（否则报错）</span><br><span class="line">    console.log(`$&#123;this.name&#125;~~, RealClass In`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const R = new RealClass(&quot;fred&quot;);</span><br><span class="line">R.getName();                          // &quot;fred~~, RealClass In&quot;</span><br></pre></td></tr></table></figure>

<h3 id="接口约束类"><a href="#接口约束类" class="headerlink" title="接口约束类"></a>接口约束类</h3><p>我们也可以使用接口，来约束类； 使用<code>implements</code>关键字来实现；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface iClass &#123;</span><br><span class="line">  type: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ParentI implements iClass &#123;</span><br><span class="line">  type: string;</span><br><span class="line">  constructor(type) &#123;</span><br><span class="line">    this.type = type;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const p = new ParentI(&quot;interface for class&quot;);</span><br><span class="line">console.log(p);</span><br></pre></td></tr></table></figure>

<h3 id="泛型中使用类"><a href="#泛型中使用类" class="headerlink" title="泛型中使用类"></a>泛型中使用类</h3><p>因为<code>类</code>和<code>类所创建实例</code>的类型就是<code>类本身</code>；</p>
<p>所以我们可以使用泛型，来定义一个类： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const test = &lt;T&gt;(p: new (par) =&gt; T, params): T =&gt; &#123;           //T表示的类型就是类本身</span><br><span class="line">  return new p(params);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class TClass &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(test(TClass, &quot;fred&quot;));     // &#123;name: &quot;fred&quot;&#125;</span><br></pre></td></tr></table></figure>



<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举（Enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等。</p>
<h3 id="数字枚举"><a href="#数字枚举" class="headerlink" title="数字枚举"></a>数字枚举</h3><p>默认如果不给初始值，那么枚举数值从0开始递增； </p>
<p>并且你也可以手动指定某个位置的枚举初始数值，紧随的未赋值枚举值就会递增；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enum Status &#123;</span><br><span class="line">  Pending = 2,</span><br><span class="line">  Failed = 0,</span><br><span class="line">  Success</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(Status.Pending);                   // 2</span><br><span class="line">console.log(Status.Failed);                   // 0</span><br><span class="line">console.log(Status.Success);                 // 1</span><br></pre></td></tr></table></figure>

<p>需要注意，如果某个枚举值使用了变量赋值 / 函数返回值赋值（计算值），那么其紧随的枚举值必须设置初始值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const tmp = 8;             // 计算值</span><br><span class="line">enum Days &#123;</span><br><span class="line">  MonDay,</span><br><span class="line">  TuesDay,</span><br><span class="line">  WedsDay = tmp,</span><br><span class="line">  ThursDay = 3           // 这里必须设置初始值，否则报错</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(Days);</span><br></pre></td></tr></table></figure>

<h3 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h3><p>使用字符串枚举时，可以在新枚举值赋值时使用已定义的枚举值直接赋值；</p>
<p>需要注意<code>含字符串值成员的枚举中不允许使用计算值</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum Msg &#123;</span><br><span class="line">  Success = &quot;okay, fined&quot;,</span><br><span class="line">  Faild = &quot;sorry, no way&quot;,</span><br><span class="line">  Error = Faild</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举接口"><a href="#枚举接口" class="headerlink" title="枚举接口"></a>枚举接口</h3><p>可以使用枚举值来作为接口类型判断；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;</span><br><span class="line">  red,</span><br><span class="line">  black</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Animal &#123;</span><br><span class="line">  color: Color.red;            // 如果类型使用Color，则为联合类型判断</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const dog: Animal = &#123;</span><br><span class="line">  color: Color.red</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(dog);</span><br></pre></td></tr></table></figure>

<h3 id="编译后的枚举"><a href="#编译后的枚举" class="headerlink" title="编译后的枚举"></a>编译后的枚举</h3><p>实际上编译后的枚举值是实际存在的，并且可以使用；不像<code>interface</code>，编译后实际不存在；</p>
<p>编译后的枚举实际上是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum Days &#123; Sun, Mon, Tue &#125;</span><br><span class="line">===========================编译后=================================================</span><br><span class="line">var Days;</span><br><span class="line">(function (Days) &#123;</span><br><span class="line">    Days[Days[&quot;Sun&quot;] = 0] = &quot;Sun&quot;;</span><br><span class="line">    Days[Days[&quot;Mon&quot;] = 1] = &quot;Mon&quot;;</span><br><span class="line">    Days[Days[&quot;Tue&quot;] = 2] = &quot;Tue&quot;;</span><br><span class="line">&#125;)(Days || (Days = &#123;&#125;));</span><br></pre></td></tr></table></figure>

<p>所以我们打印出这个<code>enum</code>枚举值，是这样的一个对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  0: &quot;Sun&quot;,</span><br><span class="line">  1: &quot;Mon&quot;,</span><br><span class="line">  2: &quot;Tue&quot;,</span><br><span class="line">  Sun: 0,</span><br><span class="line">  Mon: 1,</span><br><span class="line">  Tue: 8,</span><br><span class="line">  __proto__: Object</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们完全可以在编译后，正常使用这个对象。</p>
<p><strong>如果我们不想要编译后，生成这个<code>enum</code>对象呢？</strong></p>
<p>那我们可以在定义<code>enum</code>时，前面加一个<code>const</code>，这就代表ts不会实质创建这个对象；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const enum Days &#123; Sun, Mon, Tue &#125;</span><br><span class="line">const test = &#123; days: Days.Sun &#125;; </span><br><span class="line">===========================编译后=================================================</span><br><span class="line">var test = &#123; days: 0 /* Sun */ &#125;;</span><br></pre></td></tr></table></figure>





<h2 id="类型推论及兼容性"><a href="#类型推论及兼容性" class="headerlink" title="类型推论及兼容性"></a>类型推论及兼容性</h2><h3 id="函数的可选参数"><a href="#函数的可选参数" class="headerlink" title="函数的可选参数"></a>函数的可选参数</h3><p>函数的剩余参数使用<code>...arg</code>，灵活的处理函数；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type sum = (arr: number[], callback: (...arg: number[]) =&gt; number) =&gt; number;</span><br><span class="line"></span><br><span class="line">const handle: sum = (arr: number[], callback: (...arg: number[]) =&gt; number) =&gt; &#123;</span><br><span class="line">  return callback(...arr);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const res = handle([1, 2, 3], (...arg) =&gt; &#123;</span><br><span class="line">  return arg.reduce((a, b) =&gt; a + b, 10);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(res);                // 数组求和</span><br></pre></td></tr></table></figure>

<h2 id="类型兼容性"><a href="#类型兼容性" class="headerlink" title="类型兼容性"></a>类型兼容性</h2><p>TS的类型兼容性指类型之间的互相赋值规则</p>
<h3 id="函数的互相赋值"><a href="#函数的互相赋值" class="headerlink" title="函数的互相赋值"></a>函数的互相赋值</h3><p>如果函数的参数个数不同，那么参数少的函数体，可以赋值给参数多的函数体； </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let funC = (arg: string | number, tmp: boolean): void =&gt; &#123;&#125;;      // 两个参数</span><br><span class="line">let funD = (arg: string): void =&gt; &#123;&#125;;                          // 一个参数</span><br><span class="line"></span><br><span class="line">// funC = funD;            // true,  it&apos;s okay</span><br><span class="line">funD = funC;              // error,  false</span><br></pre></td></tr></table></figure>

<p>这里引申到函数的返回值， 同理；   </p>
<p>返回值类型多的，可以被其子集函数体赋值；反之则不行；</p>
<h3 id="函数重载的兼容"><a href="#函数重载的兼容" class="headerlink" title="函数重载的兼容"></a>函数重载的兼容</h3><p>函数重载的兼容性也一样，如果重载的类型子集的函数不可以赋值给父集类型函数；比较绕口，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function funE(arg: number, tmp: number): number;</span><br><span class="line">function funE(arg: any, tmp: any): any &#123;</span><br><span class="line">  return arg + tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function funF(arg: number, tmp: number): number;</span><br><span class="line">function funF(arg: string, tmp: string): string;</span><br><span class="line">function funF(arg: any, tmp: any): any &#123;</span><br><span class="line">  return arg + tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let funTmp = funF;                   </span><br><span class="line">funTmp = funE;            // 把funE赋值给funF错误，不允许； 因为E是F的子集；</span><br></pre></td></tr></table></figure>

<h3 id="枚举的兼容"><a href="#枚举的兼容" class="headerlink" title="枚举的兼容"></a>枚举的兼容</h3><p>枚举值可以与数值兼容，但不兼容其他枚举下的枚举值；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;</span><br><span class="line">  red,</span><br><span class="line">  black</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tmp = Color.red;</span><br><span class="line">tmp = Color.black;</span><br><span class="line">tmp = 12;</span><br><span class="line">tmp = &quot;12&quot;;          // error</span><br></pre></td></tr></table></figure>

<h3 id="类的兼容性"><a href="#类的兼容性" class="headerlink" title="类的兼容性"></a>类的兼容性</h3><p>影响类兼容性的因素</p>
<ol>
<li><p>属性的不同，包括：</p>
<ul>
<li>类静态属性名不同，属性类型不同；</li>
<li>实例属性名不同，属性类型不同；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Blue &#123;</span><br><span class="line">  public static color: string = &quot;blue&quot;;</span><br><span class="line">  constructor(public speed: number) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Red &#123;</span><br><span class="line">  public static color: string = &quot;red&quot;;</span><br><span class="line">  constructor(public speed: number) &#123;&#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    return &quot;influence&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Gray &#123;</span><br><span class="line">  public static color: number = 160;                 // 静态属性名不同，类型不同</span><br><span class="line">  constructor(public cost: number) &#123;&#125;          // 实例属性名不同</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let s = Blue;</span><br><span class="line">s = Red;</span><br><span class="line">s = Gray;                  // error， 无法兼容赋值</span><br></pre></td></tr></table></figure>
</li>
<li><p>类属性的修饰符；</p>
<p>含有修饰符属性的类，无法互相兼容</p>
<p>但如果都含有<code>public</code>，并且相同属性名，相同属性类型的类，可以互相兼容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Parent &#123;</span><br><span class="line">  private color: string;                        // 因为这个是私有属性，所以不能兼容</span><br><span class="line">  constructor(public name: string) &#123;&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    super(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Other &#123;</span><br><span class="line">  constructor(public name: string) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const classTmp: Parent = new Child(&quot;fred&quot;);                     //true, it&apos;s okay</span><br><span class="line">const classTmpOther: Parent = new Other(&quot;fred&quot;);            // error</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="函数参数的双向协变"><a href="#函数参数的双向协变" class="headerlink" title="函数参数的双向协变"></a>函数参数的双向协变</h3><p>当函数参数类型为联合类型时，只要另一个函数参数在联合类型中，那么可以互相赋值函数体；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let funA = (arg: string | number): void =&gt; &#123;&#125;;</span><br><span class="line">let funB = (arg: string): void =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// funA = funB;               // true,  it&apos;s okay</span><br><span class="line">funB = funA;                 // true,  it&apos;s okay</span><br></pre></td></tr></table></figure>




    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/TypeScript/" rel="tag"># TypeScript</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/02/22/TypeScript-01/" rel="prev" title="TypeScript初探">
      <i class="fa fa-chevron-left"></i> TypeScript初探
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#泛型"><span class="nav-number">2.</span> <span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型约束"><span class="nav-number">2.1.</span> <span class="nav-text">泛型约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#keyof"><span class="nav-number">2.2.</span> <span class="nav-text">keyof</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例：多参数泛型约束"><span class="nav-number">2.3.</span> <span class="nav-text">实例：多参数泛型约束</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ES6中的类"><span class="nav-number">3.</span> <span class="nav-text">ES6中的类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#属性和方法"><span class="nav-number">3.1.</span> <span class="nav-text">属性和方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态static方法"><span class="nav-number">3.2.</span> <span class="nav-text">静态static方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#存取器"><span class="nav-number">3.3.</span> <span class="nav-text">存取器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类的私有方法"><span class="nav-number">3.4.</span> <span class="nav-text">类的私有方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继承"><span class="nav-number">3.5.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例对象"><span class="nav-number">3.6.</span> <span class="nav-text">实例对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态方法"><span class="nav-number">3.7.</span> <span class="nav-text">静态方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#super"><span class="nav-number">3.8.</span> <span class="nav-text">super</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数方法"><span class="nav-number">3.9.</span> <span class="nav-text">函数方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象"><span class="nav-number">3.10.</span> <span class="nav-text">对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原型对象"><span class="nav-number">3.11.</span> <span class="nav-text">原型对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ES6和ES5继承的区别"><span class="nav-number">3.12.</span> <span class="nav-text">ES6和ES5继承的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TS中的类"><span class="nav-number">4.</span> <span class="nav-text">TS中的类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#修饰符"><span class="nav-number">4.1.</span> <span class="nav-text">修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#readonly修饰符"><span class="nav-number">4.2.</span> <span class="nav-text">readonly修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参数属性简写"><span class="nav-number">4.3.</span> <span class="nav-text">参数属性简写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可选属性"><span class="nav-number">4.4.</span> <span class="nav-text">可选属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#存取器-1"><span class="nav-number">4.5.</span> <span class="nav-text">存取器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象类"><span class="nav-number">4.6.</span> <span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口约束类"><span class="nav-number">4.7.</span> <span class="nav-text">接口约束类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型中使用类"><span class="nav-number">4.8.</span> <span class="nav-text">泛型中使用类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#枚举"><span class="nav-number">5.</span> <span class="nav-text">枚举</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数字枚举"><span class="nav-number">5.1.</span> <span class="nav-text">数字枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串枚举"><span class="nav-number">5.2.</span> <span class="nav-text">字符串枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#枚举接口"><span class="nav-number">5.3.</span> <span class="nav-text">枚举接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编译后的枚举"><span class="nav-number">5.4.</span> <span class="nav-text">编译后的枚举</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型推论及兼容性"><span class="nav-number">6.</span> <span class="nav-text">类型推论及兼容性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数的可选参数"><span class="nav-number">6.1.</span> <span class="nav-text">函数的可选参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型兼容性"><span class="nav-number">7.</span> <span class="nav-text">类型兼容性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数的互相赋值"><span class="nav-number">7.1.</span> <span class="nav-text">函数的互相赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数重载的兼容"><span class="nav-number">7.2.</span> <span class="nav-text">函数重载的兼容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#枚举的兼容"><span class="nav-number">7.3.</span> <span class="nav-text">枚举的兼容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类的兼容性"><span class="nav-number">7.4.</span> <span class="nav-text">类的兼容性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数参数的双向协变"><span class="nav-number">7.5.</span> <span class="nav-text">函数参数的双向协变</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="酵父"
      src="https://i.loli.net/2019/11/24/1eJtrwT9h7oLmW2.png">
  <p class="site-author-name" itemprop="name">酵父</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">酵父</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.5.0
  </div>

        








        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>

  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  
















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":280,"hOffset":-60},"mobile":{"show":true},"react":{"opacity":1},"log":false});</script></body>
</html>
