<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="goon Fred" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"always","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="什么是 TypeScript我觉得学一个东西首先肯定得先弄懂它是什么，两句话写下对TypeScript 的理解如下： TypeScript 是 JavaScript 的一个超集，主要提供了类型系统和对 ES6 的支持，它由 Microsoft 开发，代码开源于 GitHub上。 我觉得直观作用有，解决开发时自己为了健壮性对代码的类型判断，交给ts去做。 其次引用官网的定义：  TypeScript">
<meta name="keywords" content="TypeScript">
<meta property="og:type" content="article">
<meta property="og:title" content="TypeScript初探">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;02&#x2F;22&#x2F;TypeScript-01&#x2F;index.html">
<meta property="og:site_name" content="goon Fred">
<meta property="og:description" content="什么是 TypeScript我觉得学一个东西首先肯定得先弄懂它是什么，两句话写下对TypeScript 的理解如下： TypeScript 是 JavaScript 的一个超集，主要提供了类型系统和对 ES6 的支持，它由 Microsoft 开发，代码开源于 GitHub上。 我觉得直观作用有，解决开发时自己为了健壮性对代码的类型判断，交给ts去做。 其次引用官网的定义：  TypeScript">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-02-22T14:52:49.666Z">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/02/22/TypeScript-01/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>TypeScript初探 | goon Fred</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">goon Fred</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>日志</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/22/TypeScript-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://i.loli.net/2019/11/24/1eJtrwT9h7oLmW2.png">
      <meta itemprop="name" content="酵父">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="goon Fred">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          TypeScript初探
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-22 22:29:00 / 修改时间：22:52:49" itemprop="dateCreated datePublished" datetime="2020-02-22T22:29:00+08:00">2020-02-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="什么是-TypeScript"><a href="#什么是-TypeScript" class="headerlink" title="什么是 TypeScript"></a>什么是 TypeScript</h1><p>我觉得学一个东西首先肯定得先弄懂它是什么，两句话写下对TypeScript 的理解如下：</p>
<p><a href="http://www.typescriptlang.org/" target="_blank" rel="noopener">TypeScript</a> 是 JavaScript 的一个超集，主要提供了<strong>类型系统</strong>和<strong>对 ES6 的支持</strong>，它由 Microsoft 开发，代码开源于 GitHub上。</p>
<p>我觉得直观作用有，解决开发时自己为了健壮性对代码的类型判断，交给ts去做。</p>
<p>其次引用官网的定义：</p>
<blockquote>
<p>TypeScript is a typed superset of JavaScript that compiles to plain JavaScript. Any browser. Any host. Any OS. Open source.</p>
</blockquote>
<p>翻译成中文即是：</p>
<blockquote>
<p>TypeScript 是 JavaScript 的类型的超集，它可以编译成纯 JavaScript。编译出来的 JavaScript 可以运行在任何浏览器上。TypeScript 编译工具可以运行在任何服务器和任何系统上。TypeScript 是开源的。</p>
</blockquote>
<h2 id="TypeScript-的缺点"><a href="#TypeScript-的缺点" class="headerlink" title="TypeScript 的缺点"></a>TypeScript 的缺点</h2><p>任何事物都是有两面性的，TypeScript 的弊端在于：</p>
<ul>
<li>有一定的学习成本，需要理解接口（Interfaces）、泛型（Generics）、类（Classes）、枚举类型（Enums）等前端js中不是很熟悉的概念</li>
<li>短期可能会增加一些开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期维护的项目，TypeScript 能够减少其维护成本，但对于小型临时项目自己斟酌，因为毕竟写类型定义也是要额外花时间精力的</li>
<li>集成到构建流程需要一些工作量</li>
<li>可能和一些库结合的不是很完美</li>
</ul>
<p>大家可以根据自己团队和项目的情况判断是否需要使用 TypeScript。</p>
<h2 id="使用编译"><a href="#使用编译" class="headerlink" title="使用编译"></a>使用编译</h2><p>TypeScript 中，使用 <code>:</code> 指定变量的类型，<code>:</code> 的前后有没有空格都可以。</p>
<p><strong>TypeScript 编译的时候即使报错了，还是会生成编译结果</strong>，我们仍然可以使用这个编译之后的文件。</p>
<p>如果要在报错的时候终止 js 文件的生成，可以在 <code>tsconfig.json</code> 中配置 <code>noEmitOnError</code> 即可。</p>
<h1 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h1><p>JavaScript 的类型分为两种：原始数据类型和对象类型。</p>
<p><strong>原始数据类型</strong>包括：布尔值、数值、字符串、<code>null</code>、<code>undefined</code> 以及 ES6 中的新类型 <code>Symbol</code>。</p>
<p><strong>这里需要注意：</strong> </p>
<p>在 TypeScript 中，<code>boolean</code> 是 JavaScript 中的基本类型，而 <code>Boolean</code> 是 JavaScript 中的构造函数。其他基本类型（除了 <code>null</code> 和 <code>undefined</code>）一样，不再赘述。</p>
<h2 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h2><p>JavaScript 没有空值（Void）的概念，在 TypeScript 中，<strong>可以用 <code>void</code> 表示没有任何返回值的函数</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function alertName(): void &#123;</span><br><span class="line">	alert(&apos;My name is Tom&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明一个 <code>void</code> 类型的变量没有什么用，因为你只能将它赋值为 <code>undefined</code> 和 <code>null</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let unusable: void = undefined;</span><br></pre></td></tr></table></figure>

<h2 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h2><p>在 TypeScript 中，可以使用 <code>null</code> 和 <code>undefined</code> 来定义这两个原始数据类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let u: undefined = undefined;let n: null = null;</span><br></pre></td></tr></table></figure>

<p>与 <code>void</code> 的区别是，<code>undefined</code> 和 <code>null</code> 是所有类型的子类型。也就是说 <code>undefined</code> 类型的变量，可以赋值给 <code>number</code> 类型的变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 这样不会报错let num: number = undefined;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 这样也不会报错let u: undefined;let num: number = u;</span><br></pre></td></tr></table></figure>

<p>而 <code>void</code> 类型的变量不能赋值给 <code>number</code> 类型的变量；</p>
<h1 id="任意值"><a href="#任意值" class="headerlink" title="任意值"></a>任意值</h1><p>但如果是 <code>any</code> 类型，则允许被赋值为任意类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let myFavoriteNumber: any = &apos;seven&apos;;</span><br><span class="line">myFavoriteNumber = 7;</span><br></pre></td></tr></table></figure>

<h2 id="任意值的属性和方法"><a href="#任意值的属性和方法" class="headerlink" title="任意值的属性和方法"></a>任意值的属性和方法</h2><p>在任意值上访问任何属性都是允许的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let anyThing: any = &apos;Tom&apos;;</span><br><span class="line">anyThing = false;</span><br><span class="line">anyThing.setName(&apos;Jerry&apos;);</span><br><span class="line">anyThing.setName(&apos;Jerry&apos;).sayHello();</span><br><span class="line">anyThing.myName.setFirstName(&apos;Cat&apos;);</span><br></pre></td></tr></table></figure>

<p>可以认为，<strong>声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值</strong>。</p>
<h1 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h1><p>TypeScript 会在没有明确的指定类型的时候自动推测出一个类型，这就是类型推论。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let myFavoriteNumber = &apos;seven&apos;;</span><br><span class="line">myFavoriteNumber = 7;</span><br><span class="line"></span><br><span class="line">// index.ts(2,1): error TS2322: Type &apos;number&apos; is not assignable to type &apos;string&apos;.</span><br></pre></td></tr></table></figure>

<p>实际上等价于 ↓</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let myFavoriteNumber: string = &apos;seven&apos;;</span><br><span class="line">myFavoriteNumber = 7;</span><br><span class="line"></span><br><span class="line">// index.ts(2,1): error TS2322: Type &apos;number&apos; is not assignable to type &apos;string&apos;.</span><br></pre></td></tr></table></figure>

<p><strong>例外需要注意：如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成</strong> <code>any</code> <strong>类型而完全不被类型检查</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let myFavoriteNumber;</span><br><span class="line">myFavoriteNumber = &apos;seven&apos;;</span><br><span class="line">myFavoriteNumber = 7;            &lt;===== ok</span><br></pre></td></tr></table></figure>



<h1 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h1><p>联合类型使用 <code>|</code> 分隔每个类型，表示取值可以为多种类型中的一种。</p>
<h2 id="函数中访问联合类型的属性或方法"><a href="#函数中访问联合类型的属性或方法" class="headerlink" title="函数中访问联合类型的属性或方法"></a>函数中访问联合类型的属性或方法</h2><p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们<strong>只能访问此联合类型的所有类型里共有的属性或方法</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function getLength(something: string | number): number &#123;</span><br><span class="line">    return something.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 报错index.ts(2,22): error TS2339: Property &apos;length&apos; does not exist on type &apos;string | number&apos;.</span><br><span class="line">//   Property &apos;length&apos; does not exist on type &apos;number&apos;.</span><br></pre></td></tr></table></figure>

<p>上例中，<code>length</code> 不是 <code>string</code> 和 <code>number</code> 的共有属性，所以会报错。</p>
<p><strong>函数中使用的方法，必须是设置联合类型中共有的方法。</strong></p>
<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p><a href="">之前提到过</a>，当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们<strong>只能访问此联合类型的所有类型里共有的属性或方法</strong>：</p>
<p>而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型的属性或方法，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function getLength(something: string | number): number &#123;</span><br><span class="line">    if (something.length) &#123;</span><br><span class="line">        return something.length;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return something.toString().length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们就需要给不确定的类型做断言；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function getLength(something: string | number): number &#123;</span><br><span class="line">    if ((&lt;string&gt;something).length) &#123;    // 或者使用 (something as string)</span><br><span class="line">        return (&lt;string&gt;something).length;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return something.toString().length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将类型确定为string，那么就可以正常的使用length属性来做if判断;</p>
<blockquote>
<p>还有一种方法可以使用<code>类型保护</code>，这个在后面的高级类型中记录。</p>
</blockquote>
<h2 id="变量中联合类型的类型推断"><a href="#变量中联合类型的类型推断" class="headerlink" title="变量中联合类型的类型推断"></a>变量中联合类型的类型推断</h2><p>联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let myFavoriteNumber: string | number;</span><br><span class="line">myFavoriteNumber = &apos;seven&apos;;</span><br><span class="line">console.log(myFavoriteNumber.length); // 5</span><br><span class="line">myFavoriteNumber = 7;</span><br><span class="line">console.log(myFavoriteNumber.length); // 编译时报错</span><br><span class="line"></span><br><span class="line">// index.ts(5,30): error TS2339: Property &apos;length&apos; does not exist on type &apos;number&apos;.</span><br></pre></td></tr></table></figure>

<p>上例中，第二行的 <code>myFavoriteNumber</code> 被推断成了 <code>string</code>，访问它的 <code>length</code> 属性不会报错。</p>
<p>而第四行的 <code>myFavoriteNumber</code> 被推断成了 <code>number</code>，访问它的 <code>length</code> 属性时就报错了。</p>
<h1 id="对象的类型-接口"><a href="#对象的类型-接口" class="headerlink" title="对象的类型-接口"></a>对象的类型-接口</h1><h2 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h2><p>在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。</p>
<p>TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。</p>
<p><strong>我认为这里的接口可以理解为对一类对象的”形状”的具体描述，”形状”就是指这个对象的key-value结构和命名赋值方式；</strong></p>
<p><strong>相当于接口就是给一个对象造了一个固定形状的容器，后面使用这个容器生产出来的对象都是一个模样</strong></p>
<p>使用某个定义的接口，就像在给这个容器中填满内容，当你填满内容，那么出现的这个对象也就是容器的形状。</p>
<h2 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &apos;Tom&apos;,</span><br><span class="line">    age: 25</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的例子中，我们定义了一个接口 <code>Person</code>，接着定义了一个变量 <code>tom</code>，它的类型是 <code>Person</code>。这样，我们就约束了 <code>tom</code> 的形状必须和接口 <code>Person</code> 一致。</p>
<p>定义的变量比接口少了一些属性或多一些属性都是不允许的：</p>
<h2 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h2><p>有时我们希望不要完全匹配一个形状，那么可以用可选属性：</p>
<p>即使用<code>?</code>来定义key键：代表着可选</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &apos;Tom&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="任意属性"><a href="#任意属性" class="headerlink" title="任意属性"></a>任意属性</h2><p>有时候我们希望一个接口允许有任意的属性，可以使用如下方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;                   // 这里返回值也必须为string</span><br><span class="line">    [propName: string]: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &apos;Tom&apos;,</span><br><span class="line">    age: 18,                // 类型为number，报错</span><br><span class="line">    gender: &apos;male&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用 <code>[propName: string]</code> 定义了任意属性取 <code>string</code> 类型的值。</p>
<p><strong>这里需要注意，这个任意属性的写法属于索引签名； 实际意义可以理解为当我用<code>string</code>类型去索引<code>Person</code>这个接口对象的时候，返回值是<code>string</code>类型。</strong></p>
<p>也就表示，如果使用string定义了任意属性[propname]，那么对象中如果存在其他可选属性，也必须和[propname]的类型保持一致，必须是string。</p>
<p>这句话怎么理解呢？</p>
<p>所以我在一个容器中设置了任意属性，则其他指定的<code>属性</code>也必须遵循当前容器中<code>任意条件</code>的限制规则。</p>
<p>这也就能理解，为什么我设置的可选属性<code>age?:number</code>为<code>number</code>， 但我在下面定义了任意属性为<code>string</code>，这个<code>age</code>就也要限制为string类型了，否则会报错。</p>
<h2 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h2><p>有时候我们希望对象中的一些字段只能在创建的时候被赋值，后期不可修改，那么可以用 <code>readonly</code> 定义只读属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    readonly id: number;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    id: 89757,</span><br><span class="line">    name: &apos;Tom&apos;,</span><br><span class="line">    gender: &apos;male&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">tom.id = 9527;</span><br><span class="line"></span><br><span class="line">// index.ts(14,5): error TS2540: Cannot assign to &apos;id&apos; because it is a constant or a read-only property.</span><br></pre></td></tr></table></figure>

<h2 id="混合接口"><a href="#混合接口" class="headerlink" title="混合接口"></a>混合接口</h2><p>如果一个接口既描述了函数的输入与输出是一个函数接口，同时又具有其他成员，可以用来描述对象的属性或方法；那么就构成了一个混合接口；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 混合接口</span><br><span class="line">interface counter &#123;</span><br><span class="line">  (number): void</span><br><span class="line">  count: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const getCounter = (num: number): counter =&gt; &#123;</span><br><span class="line">  const c = () =&gt; &#123; c.count++ &#125;</span><br><span class="line">  c.count = num;</span><br><span class="line">  return c;</span><br><span class="line">&#125;</span><br><span class="line">getCounter.count = 6;</span><br><span class="line"></span><br><span class="line">const counter: counter = getCounter(getCounter.count);</span><br><span class="line"></span><br><span class="line">counter(getCounter.count);</span><br><span class="line">console.log(counter.count);  // 7</span><br><span class="line">counter(getCounter.count);</span><br><span class="line">console.log(counter.count); // 8</span><br></pre></td></tr></table></figure>





<h1 id="数组的类型"><a href="#数组的类型" class="headerlink" title="数组的类型"></a>数组的类型</h1><p>在 TypeScript 中，数组类型有多种定义方式，比较灵活。</p>
<h2 id="any-在数组中的应用"><a href="#any-在数组中的应用" class="headerlink" title="any 在数组中的应用"></a>any 在数组中的应用</h2><p>一个比较常见的做法是，用 <code>any</code> 表示数组中允许出现任意类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let list: any[] = [&apos;xxxxx&apos;, 25, &#123; website: &apos;http://xxxx.com&apos; &#125;];</span><br></pre></td></tr></table></figure>

<p>如果要限制数组Item类型，则替换any类型， 如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let fibonacci: number[] = [1, 1, 2, 3, 5];</span><br></pre></td></tr></table></figure>

<p>那么该数组就为一个纯数值数组，甚至不允许在内置方法中添加非数组item。</p>
<h2 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h2><p>类数组（Array-like Object）不是数组类型，比如 <code>arguments</code>，或<code>HTMLCollection</code>元素集合等。</p>
<p>常用的类数组都有自己内置的接口定义，如 <code>IArguments</code>, <code>NodeList</code>, <code>HTMLCollection</code> 等：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function sum() &#123;</span><br><span class="line">    let args: IArguments = arguments;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接使用内置对象接口即可；</p>
<h1 id="函数的类型"><a href="#函数的类型" class="headerlink" title="函数的类型"></a>函数的类型</h1><h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><p>在 JavaScript 中，有两种常见的定义函数的方式——函数声明（Function Declaration）和函数表达式（Function Expression）：</p>
<p>函数声明直接使用类型定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function sum(x: number, y: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里表示两个参数都是<code>number</code>输入，函数输出也为<code>number</code></p>
<p>注意，<strong>输入多余的（或者少于要求的）参数，是不被允许的</strong>：也就是实参要和形参个数一致。</p>
<p>函数表达式的方式看下面的<code>接口定义函数的形状</code>;</p>
<h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><p>前面提到，输入多余的（或者少于要求的）参数，是不允许的。<strong>那么如何定义可选的参数呢？</strong></p>
<p>与接口中的可选属性类似，我们用 <code>?</code> 表示可选的参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function buildName(firstName: string, lastName?: string) &#123;</span><br><span class="line">    if (lastName) &#123;</span><br><span class="line">        return firstName + &apos; &apos; + lastName;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return firstName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let tomcat = buildName(&apos;Tom&apos;, &apos;Cat&apos;);</span><br><span class="line">let tom = buildName(&apos;Tom&apos;);</span><br></pre></td></tr></table></figure>

<p>需要注意的是，可选参数必须接在必需参数后面。换句话说，<strong>可选参数后面不允许再出现必需参数了</strong>：</p>
<h2 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h2><p>在 ES6 中，我们允许给函数的参数添加默认值，<strong>TypeScript 会将添加了默认值的参数识别为可选参数</strong>：</p>
<p>此时就不受「可选参数必须接在必需参数后面」的限制了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function buildName(firstName: string = &apos;Tom&apos;, lastName: string) &#123;</span><br><span class="line">    return firstName + &apos; &apos; + lastName;</span><br><span class="line">&#125;</span><br><span class="line">let tomcat = buildName(&apos;Tom&apos;, &apos;Cat&apos;);</span><br><span class="line">let cat = buildName(undefined, &apos;Cat&apos;);</span><br></pre></td></tr></table></figure>

<p>也就是说<strong>身为默认值的可选参数</strong>，后面可以出现必须参数。</p>
<h2 id="用接口定义函数的形状"><a href="#用接口定义函数的形状" class="headerlink" title="用接口定义函数的形状"></a>用接口定义函数的形状</h2><p>我们也可以使用接口的方式来定义一个函数需要符合的形状：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface SearchFunc &#123;</span><br><span class="line">    (source: string, subString: string): boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let mySearch: SearchFunc;</span><br><span class="line">mySearch = function(source: string, subString: string) &#123;</span><br><span class="line">    return source.search(subString) !== -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样子mySearch就只能赋值为一个函数，并且这个函数的<strong>形参名，形参类型</strong>，以及这个<strong>函数的返回值</strong>类型都必须<strong>符合接口的定义形状</strong>。</p>
<h2 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h2><p>ES6 中，可以使用 <code>...rest</code> 的方式获取函数中的剩余参数（rest 参数）：</p>
<p>在TS中，我们同样可以使用…rest参数并指定类型，因为剩余参数本质是一个数组，所以给这个数组可以指定每一项的类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function push(array: any[], ...items: any[]) &#123;</span><br><span class="line">    items.forEach(function(item) &#123;</span><br><span class="line">        array.push(item);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = [];</span><br><span class="line">push(a, 1, 2, 3);</span><br></pre></td></tr></table></figure>

<p>剩余参数只能作为最后一个形参使用。</p>
<h1 id="symbol类型"><a href="#symbol类型" class="headerlink" title="symbol类型"></a>symbol类型</h1><p>ES6中的Symbol类型也在ts中完全支持；</p>
<p>类型特点：</p>
<ul>
<li><p>唯一，就算传入相同标识符，两个symbol值也互不相等；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const s1 = Symbol(&apos;sym&apos;);</span><br><span class="line">const s2 = Symbol(&apos;sym&apos;);</span><br><span class="line">console.log(s1 === s2);  // false;</span><br></pre></td></tr></table></figure>

<p>并且可用于对象中的键值，好处是不会重复；</p>
</li>
<li><p>不可遍历</p>
<p>对象中使用Symbol设置的键值对，不能通过<code>for...in</code> &amp; <code>Object.keys</code> &amp; <code>Object.getOwnPropertyNames</code>等方法遍历；</p>
<p>要想遍历，必须使用<code>Object.getOwnPropertySymbols</code> &amp; <code>Reflect.ownKeys()</code>方法获取；</p>
</li>
<li><p>可以作为类的私有方法/属性来使用；</p>
</li>
</ul>
<h2 id="Symbol的两个方法"><a href="#Symbol的两个方法" class="headerlink" title="Symbol的两个方法"></a>Symbol的两个方法</h2><ul>
<li><p>Symbol.for()</p>
<p>前文说过使用Symbol创建出来的值具有唯一性，就算使用相同标识符的两个也不相等；</p>
<p>但使用Symbol.for()创建出来的值，相当于全局Symbol，如果此前创建过相同标识的全局Symbol，那么就不会重复创建；</p>
<p>会用之前Symbol.for创建的值，来直接赋值给s2；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const s1 = Symbol.for(&apos;the&apos;);</span><br><span class="line">const s2 = Symbol.for(&apos;the&apos;);</span><br><span class="line">console.log(s1 === s2);          // true;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Symbol.forKey( )</p>
<p>返回之前使用<code>Symbol.for</code>定义的标识内容；</p>
<p>如： <code>Symbol.for(&#39;the&#39;)</code>， </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const s1 = Symbol.for(&apos;the&apos;);</span><br><span class="line">const s2 = Symbol.keyFor(s1);</span><br><span class="line">console.log(s2);          // the;</span><br></pre></td></tr></table></figure>


</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/TypeScript/" rel="tag"># TypeScript</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/01/18/GIT-SSH%E9%85%8D%E7%BD%AE/" rel="prev" title="GIT & SSH配置">
      <i class="fa fa-chevron-left"></i> GIT & SSH配置
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/02/23/typescript-02/" rel="next" title="typescript轻度进阶">
      typescript轻度进阶 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#什么是-TypeScript"><span class="nav-number">1.</span> <span class="nav-text">什么是 TypeScript</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TypeScript-的缺点"><span class="nav-number">1.1.</span> <span class="nav-text">TypeScript 的缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用编译"><span class="nav-number">1.2.</span> <span class="nav-text">使用编译</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#原始数据类型"><span class="nav-number">2.</span> <span class="nav-text">原始数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#空值"><span class="nav-number">2.1.</span> <span class="nav-text">空值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Null-和-Undefined"><span class="nav-number">2.2.</span> <span class="nav-text">Null 和 Undefined</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#任意值"><span class="nav-number">3.</span> <span class="nav-text">任意值</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#任意值的属性和方法"><span class="nav-number">3.1.</span> <span class="nav-text">任意值的属性和方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类型推论"><span class="nav-number">4.</span> <span class="nav-text">类型推论</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#联合类型"><span class="nav-number">5.</span> <span class="nav-text">联合类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#函数中访问联合类型的属性或方法"><span class="nav-number">5.1.</span> <span class="nav-text">函数中访问联合类型的属性或方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型断言"><span class="nav-number">5.2.</span> <span class="nav-text">类型断言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变量中联合类型的类型推断"><span class="nav-number">5.3.</span> <span class="nav-text">变量中联合类型的类型推断</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#对象的类型-接口"><span class="nav-number">6.</span> <span class="nav-text">对象的类型-接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是接口"><span class="nav-number">6.1.</span> <span class="nav-text">什么是接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简单的例子"><span class="nav-number">6.2.</span> <span class="nav-text">简单的例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可选属性"><span class="nav-number">6.3.</span> <span class="nav-text">可选属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#任意属性"><span class="nav-number">6.4.</span> <span class="nav-text">任意属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#只读属性"><span class="nav-number">6.5.</span> <span class="nav-text">只读属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#混合接口"><span class="nav-number">6.6.</span> <span class="nav-text">混合接口</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数组的类型"><span class="nav-number">7.</span> <span class="nav-text">数组的类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#any-在数组中的应用"><span class="nav-number">7.1.</span> <span class="nav-text">any 在数组中的应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类数组"><span class="nav-number">7.2.</span> <span class="nav-text">类数组</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数的类型"><span class="nav-number">8.</span> <span class="nav-text">函数的类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#函数声明"><span class="nav-number">8.1.</span> <span class="nav-text">函数声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可选参数"><span class="nav-number">8.2.</span> <span class="nav-text">可选参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参数默认值"><span class="nav-number">8.3.</span> <span class="nav-text">参数默认值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用接口定义函数的形状"><span class="nav-number">8.4.</span> <span class="nav-text">用接口定义函数的形状</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剩余参数"><span class="nav-number">8.5.</span> <span class="nav-text">剩余参数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#symbol类型"><span class="nav-number">9.</span> <span class="nav-text">symbol类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Symbol的两个方法"><span class="nav-number">9.1.</span> <span class="nav-text">Symbol的两个方法</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="酵父"
      src="https://i.loli.net/2019/11/24/1eJtrwT9h7oLmW2.png">
  <p class="site-author-name" itemprop="name">酵父</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">酵父</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.5.0
  </div>

        








        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>

  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  
















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":280,"hOffset":-60},"mobile":{"show":true},"react":{"opacity":1},"log":false});</script></body>
</html>
